<style>
  #graph-wrapper {
    background: linear-gradient(135deg, rgba(248, 250, 252, 0.9), rgba(241, 245, 249, 0.9));
    border-radius: 16px;
    height: auto;
    position: relative;
    overflow: hidden;
  }

  #graph-wrapper::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at 20% 30%, rgba(255, 111, 97, 0.05) 0%, transparent 50%),
      radial-gradient(circle at 80% 70%, rgba(78, 205, 196, 0.05) 0%, transparent 50%);
    pointer-events: none;
  }

  #graph-wrapper > svg {
    max-width: 100%;
    display: block;
  }

  .links line {
    stroke: url(#link-gradient);
    opacity: 0.4;
    transition: all 0.3s ease;
  }

  .links line:hover {
    opacity: 0.8;
  }

  .nodes circle {
    cursor: pointer;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
  }

  .nodes circle:hover {
    filter: drop-shadow(0 4px 12px rgba(255, 111, 97, 0.5));
  }

  .nodes circle[active] {
    filter: drop-shadow(0 0 12px rgba(255, 111, 97, 0.6));
  }

  .text text {
    cursor: pointer;
    fill: #374151;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-weight: 500;
    text-shadow:
      -1px -1px 0 rgba(255,255,255,0.8),
      1px -1px 0 rgba(255,255,255,0.8),
      -1px 1px 0 rgba(255,255,255,0.8),
      1px 1px 0 rgba(255,255,255,0.8);
    transition: all 0.3s ease;
  }

  .text text:hover {
    fill: #FF6F61;
  }

  .text text[active] {
    fill: #FF6F61;
    font-weight: 700;
  }

  .inactive {
    opacity: 0.15;
    transition: all 0.3s ease;
  }

  .hidden {
    display: none !important;
  }

  /* Node colors by category */
  .node-investing { fill: #10B981; }
  .node-theory { fill: #3B82F6; }
  .node-dev { fill: #8B5CF6; }
  .node-ai { fill: #F59E0B; }
  .node-default { fill: url(#node-gradient); }
</style>

<div id="graph-wrapper">
  <script>
    window.addEventListener("load", loadGraph);

    function loadGraph() {
      var oScript = document.createElement("script");
      oScript.src = "https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js";
      oScript.crossOrigin = 'anonymous';
      oScript.integrity =
        "sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==";
      document.body.appendChild(oScript);
      oScript.onload = () => {
        const MINIMAL_NODE_SIZE = 8;
        const MAX_NODE_SIZE = 14;
        const ACTIVE_RADIUS_FACTOR = 1.5;
        const STROKE = 1.5;
        const FONT_SIZE = 14;
        const TICKS = 200;
        const FONT_BASELINE = 40;
        const MAX_LABEL_LENGTH = 50;

        const graphData = {% include notes_graph.json %}
        let nodesData = graphData.nodes;
        let linksData = graphData.edges;

        const nodeSize = {};

        // Category helpers
        const getCategory = (path) => {
          if (!path) return 'default';
          if (path.includes('/investing/')) return 'research';
          if (path.includes('/market-analysis/')) return 'research';
          if (path.includes('/theory/')) return 'theory';
          if (path.includes('/dev/')) return 'dev';
          if (path.includes('/ai/')) return 'ai';
          return 'default';
        };

        // Category color mapping
        const getCategoryColor = (path) => {
          const cat = getCategory(path);
          if (cat === 'research') return '#10B981';
          if (cat === 'theory') return '#3B82F6';
          if (cat === 'dev') return '#8B5CF6';
          if (cat === 'ai') return '#F59E0B';
          return null; // Will use gradient
        };

        const updateNodeSize = () => {
          nodesData.forEach((el) => {
            let weight =
              3 *
              Math.sqrt(
                linksData.filter((l) => l.source.id === el.id || l.target.id === el.id)
                  .length + 1
              );
            if (weight < MINIMAL_NODE_SIZE) {
              weight = MINIMAL_NODE_SIZE;
            } else if (weight > MAX_NODE_SIZE) {
              weight = MAX_NODE_SIZE;
            }
            nodeSize[el.id] = weight;
          });
        };

        const togglePin = (d) => {
          if (d._pinned) {
            d._pinned = false;
            d.fx = null;
            d.fy = null;
          } else {
            d._pinned = true;
            d.fx = d.x;
            d.fy = d.y;
          }
        };

        const onClick = (d) => {
          // Shift+Click: pin/unpin (sticky)
          if (d3.event && d3.event.shiftKey) {
            togglePin(d);
            // Keep sim alive a bit
            if (isGraphPage) simulation.alpha(0.6).restart();
            return;
          }
          window.location = d.path
        };

        const onMouseover = function (d) {
          const relatedNodesSet = new Set();
          linksData
            .filter((n) => n.target.id == d.id || n.source.id == d.id)
            .forEach((n) => {
              relatedNodesSet.add(n.target.id);
              relatedNodesSet.add(n.source.id);
            });

          node.attr("class", (node_d) => {
            if (node_d.id !== d.id && !relatedNodesSet.has(node_d.id)) {
              return "inactive";
            }
            return "";
          });

          link.attr("class", (link_d) => {
            if (link_d.source.id !== d.id && link_d.target.id !== d.id) {
              return "inactive";
            }
            return "";
          });

          link.attr("stroke-width", (link_d) => {
            if (link_d.source.id === d.id || link_d.target.id === d.id) {
              return STROKE * 3;
            }
            return STROKE;
          });
          text.attr("class", (text_d) => {
            if (text_d.id !== d.id && !relatedNodesSet.has(text_d.id)) {
              return "inactive";
            }
            return "";
          });
        };

        const onMouseout = function (d) {
          node.attr("class", "");
          link.attr("class", "");
          text.attr("class", "");
          link.attr("stroke-width", STROKE);
        };

        const sameNodes = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const map = new Map();
          for (const node of previous) {
            map.set(node.id, node.label);
          }

          for (const node of next) {
            const found = map.get(node.id);
            if (!found || found !== node.title) {
              return false;
            }
          }

          return true;
        };

        const sameEdges = (previous, next) => {
          if (next.length !== previous.length) {
            return false;
          }

          const set = new Set();
          for (const edge of previous) {
            set.add(`${edge.source.id}-${edge.target.id}`);
          }

          for (const edge of next) {
            if (!set.has(`${edge.source.id}-${edge.target.id}`)) {
              return false;
            }
          }

          return true;
        };

        const graphWrapper = document.getElementById('graph-wrapper')
        const element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        element.setAttribute("width", graphWrapper.getBoundingClientRect().width);
        element.setAttribute("height", window.innerHeight * 0.8);
        graphWrapper.appendChild(element);

        const reportWindowSize = () => {
          element.setAttribute("width", window.innerWidth);
          element.setAttribute("height", window.innerHeight);
        };

        window.onresize = reportWindowSize;

        const svg = d3.select("svg");
        const width = Number(svg.attr("width"));
        const height = Number(svg.attr("height"));
        let zoomLevel = 1;

        // Add gradients
        const defs = svg.append("defs");

        // Node gradient
        const nodeGradient = defs.append("linearGradient")
          .attr("id", "node-gradient")
          .attr("x1", "0%").attr("y1", "0%")
          .attr("x2", "100%").attr("y2", "100%");
        nodeGradient.append("stop").attr("offset", "0%").attr("stop-color", "#FF6F61");
        nodeGradient.append("stop").attr("offset", "100%").attr("stop-color", "#4ECDC4");

        // Link gradient
        const linkGradient = defs.append("linearGradient")
          .attr("id", "link-gradient")
          .attr("x1", "0%").attr("y1", "0%")
          .attr("x2", "100%").attr("y2", "100%");
        linkGradient.append("stop").attr("offset", "0%").attr("stop-color", "#FF6F61").attr("stop-opacity", "0.6");
        linkGradient.append("stop").attr("offset", "100%").attr("stop-color", "#4ECDC4").attr("stop-opacity", "0.6");

        // ===== Scoring (hub-ness) =====
        const degree = new Map();
        nodesData.forEach(n => degree.set(n.id, 0));
        linksData.forEach(l => {
          degree.set(l.source.id, (degree.get(l.source.id) || 0) + 1);
          degree.set(l.target.id, (degree.get(l.target.id) || 0) + 1);
        });
        const maxDeg = Math.max(...Array.from(degree.values()), 1);
        nodesData.forEach(n => {
          const d = degree.get(n.id) || 0;
          // Normalize 0..1
          n._deg = d;
          n._hub = d / maxDeg;
        });

        // Keep the /graph page dynamic. Other embeds (home) stay settled/static.
        const isGraphPage = !!document.getElementById('graph-controls');

        // Hub targets (for sticky-ish centrality) â€” only used on the graph page.
        const HUB_COUNT = 10;
        const hubs = [...nodesData]
          .sort((a, b) => (b._deg || 0) - (a._deg || 0))
          .slice(0, HUB_COUNT);

        const simulation = d3
          .forceSimulation(nodesData)
          .velocityDecay(isGraphPage ? 0.35 : 0.6)
          .alphaDecay(isGraphPage ? 0.02 : 0.12)
          .force(
            "forceX",
            d3.forceX(width / 2).strength(d => isGraphPage ? (0.02 + 0.12 * (d._hub || 0)) : 0.06)
          )
          .force(
            "forceY",
            d3.forceY(height / 2).strength(d => isGraphPage ? (0.02 + 0.12 * (d._hub || 0)) : 0.06)
          )
          .force("charge", d3.forceManyBody().strength(d => isGraphPage ? (-60 - 140 * (d._hub || 0)) : -100))
          .force(
            "link",
            d3
              .forceLink(linksData)
              .id((d) => d.id)
              .distance(d => isGraphPage ? (90 - 30 * (d.source._hub || 0)) : 100)
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(d => 18 + (nodeSize[d.id] || MINIMAL_NODE_SIZE) * 2.2))
          .stop();

        // Make top hubs "sticky" near the center by pinning them to a small circle.
        if (isGraphPage) {
          const cx = width / 2;
          const cy = height / 2;
          const r = Math.min(width, height) * 0.08;
          hubs.forEach((n, i) => {
            const a = (2 * Math.PI * i) / Math.max(hubs.length, 1);
            n.fx = cx + r * Math.cos(a);
            n.fy = cy + r * Math.sin(a);
            n._pinned = true;
          });
        }

        const g = svg.append("g");
        let link = g.append("g").attr("class", "links").selectAll(".link");
        let node = g.append("g").attr("class", "nodes").selectAll(".node");
        let text = g.append("g").attr("class", "text").selectAll(".text");

        const resize = () => {
          if (d3.event) {
            const scale = d3.event.transform;
            zoomLevel = scale.k;
            g.attr("transform", scale);
          }

          const zoomOrKeep = (value) => (zoomLevel >= 1 ? value / zoomLevel : value);

          const font = Math.max(Math.round(zoomOrKeep(FONT_SIZE)), 1);

          text.attr("font-size", (d) => font);
          text.attr("y", (d) => d.y - zoomOrKeep(FONT_BASELINE) + 8);
          link.attr("stroke-width", zoomOrKeep(STROKE));
          node.attr("r", (d) => {
            return zoomOrKeep(nodeSize[d.id]);
          });
          svg
            .selectAll("circle")
            .filter((_d, i, nodes) => d3.select(nodes[i]).attr("active"))
            .attr("r", (d) => zoomOrKeep(ACTIVE_RADIUS_FACTOR * nodeSize[d.id]));
        };

        const ticked = () => {
          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
          text
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - (FONT_BASELINE - nodeSize[d.id]) / zoomLevel);
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);
        };

        const drag = d3.drag()
          .on('start', (d) => {
            if (!d3.event.active && isGraphPage) simulation.alphaTarget(0.2).restart();
            d._pinned = true;
            d.fx = d.x;
            d.fy = d.y;
          })
          .on('drag', (d) => {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          })
          .on('end', (d) => {
            if (!d3.event.active && isGraphPage) simulation.alphaTarget(0);
          });

        const restart = () => {
          updateNodeSize();
          node = node.data(nodesData, (d) => d.id);
          node.exit().remove();
          node = node
            .enter()
            .append("circle")
            .attr("r", (d) => {
              return nodeSize[d.id];
            })
            .attr("fill", (d) => getCategoryColor(d.path) || "url(#node-gradient)")
            .attr("stroke", (d) => (d._pinned ? '#111827' : null))
            .attr("stroke-width", (d) => (d._pinned ? 2 : null))
            .call(drag)
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(node);

          link = link.data(linksData, (d) => `${d.source.id}-${d.target.id}`);
          link.exit().remove();
          link = link.enter().append("line").attr("stroke-width", STROKE).merge(link);

          text = text.data(nodesData, (d) => d.label);
          text.exit().remove();
          text = text
            .enter()
            .append("text")
            .text((d) => shorten(d.label.replace(/_*/g, ""), MAX_LABEL_LENGTH))
            .attr("font-size", `${FONT_SIZE}px`)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "central")
            .on("click", onClick)
            .on("mouseover", onMouseover)
            .on("mouseout", onMouseout)
            .merge(text);

          node.attr("active", (d) => isCurrentPath(d.path) ? true : null);
          text.attr("active", (d) => isCurrentPath(d.path) ? true : null);

          simulation.nodes(nodesData);
          simulation.force("link").links(linksData);

          // Render continuously on the /graph page; elsewhere, settle to a static layout.
          if (isGraphPage) {
            simulation.on('tick', ticked);
            simulation.alpha(1).restart();
          } else {
            simulation.alpha(1).restart();
            simulation.stop();
            for (let i = 0; i < TICKS; i++) simulation.tick();
            ticked();
          }
        };

        const zoomHandler = d3.zoom().scaleExtent([0.2, 3]).on("zoom", resize);

        zoomHandler(svg);
        restart();

        // ===== Graph View controls (only when #graph-controls exists) =====
        const controls = document.getElementById('graph-controls');
        const state = {
          allowed: new Set(['research', 'theory', 'dev', 'ai', 'default']),
          focusedId: null,
          neighborsOnly: false,
        };

        const getNeighborsSet = (id) => {
          const s = new Set([id]);
          linksData.forEach((l) => {
            const a = l.source.id;
            const b = l.target.id;
            if (a === id) s.add(b);
            if (b === id) s.add(a);
          });
          return s;
        };

        const applyVisibility = () => {
          const neighborSet = (state.neighborsOnly && state.focusedId) ? getNeighborsSet(state.focusedId) : null;

          node.attr('class', (d) => {
            const catOk = state.allowed.has(getCategory(d.path));
            const neighOk = !neighborSet || neighborSet.has(d.id);
            if (!catOk || !neighOk) return 'inactive';
            return '';
          });

          text.attr('class', (d) => {
            const catOk = state.allowed.has(getCategory(d.path));
            const neighOk = !neighborSet || neighborSet.has(d.id);
            if (!catOk || !neighOk) return 'inactive';
            return '';
          });

          link.attr('class', (d) => {
            const a = d.source.id;
            const b = d.target.id;
            const aNode = nodesData.find(n => n.id === a);
            const bNode = nodesData.find(n => n.id === b);
            const catOk = (!aNode || state.allowed.has(getCategory(aNode.path))) && (!bNode || state.allowed.has(getCategory(bNode.path)));
            const neighOk = !neighborSet || (neighborSet.has(a) && neighborSet.has(b));
            if (!catOk || !neighOk) return 'inactive';
            return '';
          });
        };

        const focusNode = (target) => {
          if (!target) return;
          state.focusedId = target.id;

          node.attr('active', (d) => (d.id === target.id ? true : null));
          text.attr('active', (d) => (d.id === target.id ? true : null));

          // Center/zoom
          const el = document.querySelector('#graph-wrapper svg');
          const w = Number(el.getAttribute('width')) || window.innerWidth;
          const h = Number(el.getAttribute('height')) || window.innerHeight;
          const scale = 1.4;
          const tx = (w / 2) - target.x * scale;
          const ty = (h / 2) - target.y * scale;

          svg.transition().duration(450).call(
            zoomHandler.transform,
            d3.zoomIdentity.translate(tx, ty).scale(scale)
          );

          applyVisibility();
        };

        const resetView = () => {
          state.allowed = new Set(['research', 'theory', 'dev', 'ai', 'default']);
          state.focusedId = null;
          state.neighborsOnly = false;

          node.attr('active', null);
          text.attr('active', null);

          if (controls) {
            document.querySelectorAll('.graph-filter').forEach(cb => cb.checked = true);
            const nb = document.getElementById('graph-neighbors');
            if (nb) nb.checked = false;
            const search = document.getElementById('graph-search');
            if (search) search.value = '';
          }

          svg.transition().duration(350).call(zoomHandler.transform, d3.zoomIdentity);
          applyVisibility();
        };

        if (controls) {
          const search = document.getElementById('graph-search');
          const resetBtn = document.getElementById('graph-reset');
          const neighborsToggle = document.getElementById('graph-neighbors');

          document.querySelectorAll('.graph-filter').forEach((cb) => {
            cb.addEventListener('change', () => {
              const v = cb.value;
              if (cb.checked) state.allowed.add(v);
              else state.allowed.delete(v);
              applyVisibility();
            });
          });

          if (neighborsToggle) {
            neighborsToggle.addEventListener('change', () => {
              state.neighborsOnly = neighborsToggle.checked;
              applyVisibility();
            });
          }

          if (resetBtn) resetBtn.addEventListener('click', resetView);

          if (search) {
            const doSearch = () => {
              const q = (search.value || '').trim().toLowerCase();
              if (!q) return;
              // exact match first
              let hit = nodesData.find(n => (n.label || '').toLowerCase() === q);
              if (!hit) hit = nodesData.find(n => (n.label || '').toLowerCase().includes(q));
              if (hit) focusNode(hit);
            };
            search.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') doSearch();
            });
          }

          // Also allow clicking a node to set focus.
          // Shift+click keeps the node on screen (pin/unpin) without navigating.
          node.on('click', (d) => {
            focusNode(d);
            onClick(d);
          });
          text.on('click', (d) => {
            focusNode(d);
            onClick(d);
          });

          applyVisibility();
        }

        function isCurrentPath(notePath) {
          return window.location.pathname.includes(notePath)
        }

        function shorten(str, maxLen, separator = ' ') {
          if (str.length <= maxLen) return str;
          return str.substr(0, str.lastIndexOf(separator, maxLen)) + '...';
        }
      }
    }
  </script>
</div>
